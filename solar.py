# -*- Mode: Python -*-

# updated may 2016.

# --------------------------------------------------------------------------------
# user-adjustable parameters
# --------------------------------------------------------------------------------

# XXX model the winter/summer tiers exactly
# XXX maybe read this from a datafile?
tiers = [
    # 2016: baseline is 10.5kWh/day (winter 10.9, summer 10.1)
    # note: averaging the two tier rates seen on march bill.
    (10.5 * 1.0, (.18212 + .18212) / 2), # 100% baseline
    (10.5 * 0.3, (.25444 + .22481) / 2), # 101%-130%
    (10.5 * 0.7, (.25444 + .28578) / 2), # 130%-200%
    (1000.0    , (.37442 + .36389) / 2), # 200%+
    ]

# from pge.com, kWh/month.  Adjusted from my actual usage apr 2015 - apr 2016.
#            [jan ... dec]
actual_usage = [902, 795, 829, 828, 681, 1239, 1288, 1180, 1227, 947, 858, 954]

# --------------------------------------------------------------------------------

# convert annual yield to monthly yield
def per_month (p):
    return ((1 + p)**(1/12.))-1

class scenario:

    def __init__ (self, name, base, cost, size):
        # starting tiers
        self.tiers = tiers[:]
        # we start out with this amount of money
        self.base = base
        # cost of the solar system
        self.cost = cost
        # we're worth this much
        self.worth = base - cost
        # solar panel output
        self.size = size

    def tiers_month (self, kwh):
        # given current tiers, how much will <kwh> cost.
        # [XXX apply seasonal rate tiers]
        total = 0.0
        for diem, cost in self.tiers:
            chunk = min (diem * 30, kwh)
            total += cost * chunk
            kwh -= chunk
        return total

    def bump_tiers (self):
        for i in range (len (self.tiers)):
            baseline, rate = self.tiers[i]
            rate += rate * rate_rise_per_month
            self.tiers[i] = baseline, rate

    def one_month (self, month):
        # increase net worth by market rate
        self.worth += self.worth * eq_per_month
        # get usage for this month
        kwh = actual_usage[month]
        # subtract power generated by solar panels
        gen = estimate_output (month, self.size)
        if gen > kwh:
            nem = gen - kwh
            ecost = - args.nem * nem
            #print 'NEM: %0.2f' % (-ecost,)
        else:
            net = kwh - gen
            assert (net > 0)
            ecost = self.tiers_month (net)
        # subtract(/add) the electric bill
        self.worth -= ecost
        # adjust bill for rate rises
        self.bump_tiers()

    def pprint (self):
        print '%10.2f' % (self.worth,)

    def go (self, years=10):
        r = []
        for i in range (years):
            for j in range (12):
                self.one_month (j)
            r.append (self.worth)
        return r

# --------------------------------------------------------------------------------
#                           read the pvwatts CSV file
# --------------------------------------------------------------------------------

# pvwatts CSV is strange: the header is formatted with CRLF rather than LF,
#  but the data lines all use just LF.

def read_csv (data):

    COMMA = 0
    TOKEN = 1
    EOL   = 2

    def gen_tokens():
        state = 0
        token = []
        for ch in data:
            # state machine:
            #  0 outside quote
            #  1 inside quote
            if state == 0:
                # outside a quote
                if ch == '"':
                    state = 1
                elif ch == ',':
                    yield COMMA, ','
                elif ch == '\n':
                    yield EOL, '\n'
                else:
                    raise SyntaxError (ch)
            elif state == 1:
                # inside a quote
                if ch == '"':
                    yield TOKEN, ''.join (token)
                    token = []
                    state = 0
                elif ch == '\\':
                    # escape not yet supported
                    raise SyntaxError (ch)
                elif ch == '\n':
                    raise SyntaxError (ch)
                else:
                    token.append (ch)
        assert state == 0

    # normalize whacky newlines
    data = data.replace ('\r\n', '\n')
    data = data.replace ('\r', '\n')

    line = []
    for kind, value in gen_tokens():
        if kind is TOKEN:
            line.append (value)
        elif kind is EOL:
            yield line
            line = []
        elif kind is COMMA:
            pass
    assert (line == [])

def stripquotes (s):
    assert (s[0] == '"')
    assert (s[-1] == '"')
    return s[1:-1]

def read_pvwatts_monthly (path):
    f = open (path, 'rb')
    size = 0.0
    gen = read_csv (f.read())
    # read header
    parts = None
    while 1:
        parts = gen.next()
        if parts == []:
            break
        elif parts[0] == 'DC System Size (kW):':
            size = float (parts[1])
        else:
            pass
    # read data
    parts = gen.next()
    assert parts[0] == 'Month'
    result = []
    for i in range (12):
        result.append (gen.next())
    # done.
    return size, result

# --------------------------------------------------------------------------------

def estimate_output (month, size):
    watts = float (pvwatts_monthly[month][1])
    # adjust watts per system size
    ratio = size / (pvwatts_size * 1000)
    return watts * ratio

# base is a made-up number to reflect a pool of money
#  that is either used to pay electric bills, pay
#  for a solar installation, or earn money invested
#  in markets/bonds/etc at the --roi value.

def go():
    import sys

    results = []
    for s in scenarios:
        x = scenario (*s)
        results.append (x.go (args.years))

    sys.stdout.write ('yr ')
    for j in range (len (scenarios)):
        sys.stdout.write ('%11s ' % (scenarios[j][0]))
    sys.stdout.write ('\n')
    for i in range (len (results[0])):
        sys.stdout.write ('%2d ' % (i+1,))
        for j in range (len (scenarios)):
            sys.stdout.write ('%10.0f ' % (results[j][i]))
            if results[j][i] >= results[0][i]:
                sys.stdout.write ('+')
            else:
                sys.stdout.write ('-')
        sys.stdout.write ('\n')

import argparse

p = argparse.ArgumentParser (description="solar scenario calculator")
p.add_argument ('--roi',        help='return on investment (default 10%%/yr)', type=float, default=10)
p.add_argument ('--years',      help='years to simulate', type=int, default=15)
p.add_argument ('--nem',        help='NEM payment per kWh', type=float, default=0.035)
p.add_argument ('--cpw',        help='cost per watt installed', type=float, default=5.0)
p.add_argument ('--rate-rise',  help='rise in rates per year (default 6.7%%/yr)', type=float, default=6.7)
p.add_argument ('--base',       help='starting pool of money', type=float, default=100000)
p.add_argument ('--pvwatts',    help='pvwatts csv file', type=str, required=True)

args = p.parse_args()

pvwatts_size, pvwatts_monthly = read_pvwatts_monthly (args.pvwatts)

eq_per_year = args.roi / 100.0
eq_per_month = per_month (eq_per_year)

# according to this page: http://www.sungevity.com/solar-cost-savings
# california rates historically go up by 6.7% per year
#  [this jives with a rise from $0.18 in 2005 to $0.32 in 2014 in the middle tier]

rate_rise_per_year = args.rate_rise / 100.0
rate_rise_per_month = per_month (rate_rise_per_year)

cpw = args.cpw

# add solar scenarios

#              name, base, cost, size
scenarios = [('none', args.base, 0, 0)]

for size in [10, 7.5, 5, 4, 3, 2]:
    scenarios.append ((
        '%.1fkW' % (size,),
        args.base,
        size * 1000 * cpw,
        size * 1000
        ))

go()
